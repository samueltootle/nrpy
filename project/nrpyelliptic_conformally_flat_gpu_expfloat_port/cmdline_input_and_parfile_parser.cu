#include "BHaH_defines.h"
#include <ctype.h>
#include <errno.h>
#include <string.h>
#define NUM_PARAMETERS 30 // Define the number of parameters
#define LINE_SIZE 1024    // Define the max size of a line
#define PARAM_SIZE 128    // Define the max param string size

static char *trim_space(char *str) {
  char *end;

  // Trim leading spaces
  while (isspace((unsigned char)*str))
    str++;

  // Trim trailing spaces
  end = str + strlen(str) - 1;
  while (end > str && isspace((unsigned char)*end))
    end--;

  *(end + 1) = '\0';

  return str;
}

static void safe_copy(char *dest, const char *src, size_t size) {
  if (src == NULL) {
    fprintf(stderr, "Error: Source string is NULL.\n");
    exit(1);
  }
  if (dest == NULL) {
    fprintf(stderr, "Error: Destination string is NULL.\n");
    exit(1);
  }
  if (size == 0) {
    fprintf(stderr, "Error: Size is zero.\n");
    exit(1);
  }
  size_t src_len = strlen(src);
  if (src_len >= size) {
    fprintf(stderr, "Error: Buffer overflow detected.\n");
    exit(1);
  }
  strncpy(dest, src, size - 1);
  dest[size - 1] = '\0';
}
// Function to print usage instructions
static void print_usage() {
  fprintf(stderr, "Usage option 0: ./nrpyelliptic_conformally_flat_gpu_expfloat [--help or -h] <- Outputs this usage command\n");
  fprintf(stderr,
          "Usage option 1: ./nrpyelliptic_conformally_flat_gpu_expfloat <- reads in parameter file nrpyelliptic_conformally_flat_gpu_expfloat.par\n");
  fprintf(stderr, "Usage option 2: ./nrpyelliptic_conformally_flat_gpu_expfloat [parfile] <- reads in parameter file [parfile]\n");
  fprintf(stderr, "Usage option 3: ./nrpyelliptic_conformally_flat_gpu_expfloat [convergence_factor] <- overwrites parameters in list after reading "
                  "in nrpyelliptic_conformally_flat_gpu_expfloat.par\n");
  fprintf(stderr, "Usage option 4: ./nrpyelliptic_conformally_flat_gpu_expfloat [parfile] [convergence_factor] <- overwrites list of steerable "
                  "parameters after reading in [parfile]\n");
}
static void read_integer(const char *value, int *result, const char *param_name) {
  char *endptr;
  errno = 0; // To detect overflow
  long int_val = strtol(value, &endptr, 10);

  if (endptr == value || *endptr != '\0' || errno == ERANGE) {
    fprintf(stderr, "Error: Invalid integer value for %s: %s.\n", param_name, value);
    exit(1);
  }

  *result = (int)int_val;
}

static void read_REAL(const char *value, REAL *result, const char *param_name) {
  char *endptr;
  errno = 0; // To detect overflow
  double double_val = strtod(value, &endptr);

  if (endptr == value || *endptr != '\0' || errno == ERANGE) {
    fprintf(stderr, "Error: Invalid double value for %s: %s.\n", param_name, value);
    exit(1);
  }

  *result = (REAL)double_val;
}

static void read_chararray(const char *value, char *result, const char *param_name, size_t size) {
  if (strlen(value) >= size) {
    fprintf(stderr, "Error: Buffer overflow detected for %s.\n", param_name);
    exit(1);
  }
  safe_copy(result, value, size);
}

static void read_boolean(const char *value, bool *result, const char *param_name) {
  // To allow case-insensitive comparison
  char *lower_value = strdup(value);
  for (char *p = lower_value; *p != '\0'; p++) {
    *p = tolower(*p);
  }

  // Check if the input is "true", "false", "0", or "1"
  if (strcmp(lower_value, "true") == 0 || strcmp(lower_value, "1") == 0) {
    *result = true;
  } else if (strcmp(lower_value, "false") == 0 || strcmp(lower_value, "0") == 0) {
    *result = false;
  } else {
    fprintf(stderr, "Error: Invalid boolean value for %s: %s.\n", param_name, value);
    free(lower_value);
    exit(1);
  }

  // Free the allocated memory for the lowercase copy of the value
  free(lower_value);
}

/*
 * AUTOMATICALLY GENERATED BY parameter_file_read_and_parse.py
 * parameter_file_read_and_parse() function:
 * Reads and parses a parameter file to populate commondata_struct commondata.
 *
 * This function takes in the command-line arguments and a pointer to a commondata_struct.
 * It reads the provided file and extracts the parameters defined in the file, populating
 * the commondata_struct with the values. The file is expected to contain key-value pairs
 * separated by an equals sign (=), and it may include comments starting with a hash (#).
 * The function handles errors such as file opening failure, duplicate parameters, and
 * invalid parameter names.
 *
 * @param griddata_params: Pointer to the commondata struct to be populated.
 * @param argc: The argument count from the command-line input.
 * @param argv: The argument vector containing command-line arguments.
 */
void cmdline_input_and_parfile_parser(commondata_struct *restrict commondata, int argc, const char *argv[]) {
  const int number_of_steerable_parameters = 1;

  int option;

  // Check for "-h" or "--help" options
  if (argc == 2 && (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0)) {
    print_usage();
    exit(0);
  }

  // Determine the usage option based on argc
  if (argc == 1) {
    option = 1; // Usage option 1: Process default parameter file "nrpyelliptic_conformally_flat_gpu_expfloat.par"
  } else if (argc == 2) {
    // Check if the argument is a file
    FILE *file_check = fopen(argv[1], "r");
    if (file_check != NULL) {
      fclose(file_check);
      option = 2; // Usage option 2: Process parameter file provided in argv[1]
    } else if (argc == 1 + number_of_steerable_parameters) {
      option = 3;
    } else {
      fprintf(stderr, "Error: Invalid number of arguments or file cannot be opened.\n");
      print_usage();
      exit(1);
    }
  } else if (argc == 1 + number_of_steerable_parameters) {
    option = 3; // Usage option 3: Overwrite steerable parameters after processing "nrpyelliptic_conformally_flat_gpu_expfloat.par"
  } else if (argc == 2 + number_of_steerable_parameters) {
    // Check if the first argument is a file
    FILE *file_check = fopen(argv[1], "r");
    if (file_check != NULL) {
      fclose(file_check);
      option = 4; // Usage option 4: Overwrite steerable parameters after processing parameter file provided in argv[1]
    } else {
      fprintf(stderr, "Error: File cannot be opened for option 4.\n");
      print_usage();
      exit(1);
    }
  } else {
    fprintf(stderr, "Error: Invalid number of arguments\n");
    print_usage();
    exit(1);
  }

  // fprintf(stderr, "Using option %d\n", option);

  const char *filename = (option == 1 || option == 3) ? "nrpyelliptic_conformally_flat_gpu_expfloat.par" : argv[1];
  FILE *file = fopen(filename, "r");
  if (file == NULL) {
    print_usage();
    exit(1);
  }

  char line[LINE_SIZE];
  char param[PARAM_SIZE];
  char value[PARAM_SIZE];
  int params_set[NUM_PARAMETERS] = {0}; // Record of parameters set (one for each parameter in the struct)

  while (fgets(line, sizeof(line), file)) {
    // Removing comments from the line
    char *comment_start = strchr(line, '#');
    if (comment_start != NULL) {
      *comment_start = '\0';
    }

    char *p = strtok(line, "=");
    if (p) {
      safe_copy(param, trim_space(p), sizeof(param));
      p = strtok(NULL, "=");
      if (p) {
        safe_copy(value, trim_space(p), sizeof(value));

        // Check for naming convention violations
        for (int i = 0; param[i]; i++) {
          if (!isalnum(param[i]) && param[i] != '_') {
            fprintf(stderr, "Error: Invalid parameter name %s.\n", param);
            exit(1);
          }
        }

        int param_index = -1;
        if (1 == 0)
          param_index = -2;
        else if (strcmp(param, "CFL_FACTOR") == 0)
          param_index = 0;
        else if (strcmp(param, "MINIMUM_GLOBAL_WAVESPEED") == 0)
          param_index = 1;
        else if (strcmp(param, "NUMGRIDS") == 0)
          param_index = 2;
        else if (strcmp(param, "P0_x") == 0)
          param_index = 3;
        else if (strcmp(param, "P0_y") == 0)
          param_index = 4;
        else if (strcmp(param, "P0_z") == 0)
          param_index = 5;
        else if (strcmp(param, "P1_x") == 0)
          param_index = 6;
        else if (strcmp(param, "P1_y") == 0)
          param_index = 7;
        else if (strcmp(param, "P1_z") == 0)
          param_index = 8;
        else if (strcmp(param, "S0_x") == 0)
          param_index = 9;
        else if (strcmp(param, "S0_y") == 0)
          param_index = 10;
        else if (strcmp(param, "S0_z") == 0)
          param_index = 11;
        else if (strcmp(param, "S1_x") == 0)
          param_index = 12;
        else if (strcmp(param, "S1_y") == 0)
          param_index = 13;
        else if (strcmp(param, "S1_z") == 0)
          param_index = 14;
        else if (strcmp(param, "bare_mass_0") == 0)
          param_index = 15;
        else if (strcmp(param, "bare_mass_1") == 0)
          param_index = 16;
        else if (strcmp(param, "checkpoint_every") == 0)
          param_index = 17;
        else if (strcmp(param, "convergence_factor") == 0)
          param_index = 18;
        else if (strcmp(param, "diagnostics_output_every") == 0)
          param_index = 19;
        else if (strcmp(param, "eta_damping") == 0)
          param_index = 20;
        else if (strcmp(param, "gridding_choice") == 0)
          param_index = 21;
        else if (strcmp(param, "log10_current_residual") == 0)
          param_index = 22;
        else if (strcmp(param, "log10_residual_tolerance") == 0)
          param_index = 23;
        else if (strcmp(param, "nn_max") == 0)
          param_index = 24;
        else if (strcmp(param, "outer_bc_type") == 0)
          param_index = 25;
        else if (strcmp(param, "output_progress_every") == 0)
          param_index = 26;
        else if (strcmp(param, "stop_relaxation") == 0)
          param_index = 27;
        else if (strcmp(param, "t_final") == 0)
          param_index = 28;
        else if (strcmp(param, "zPunc") == 0)
          param_index = 29;
        else
          fprintf(stderr, "Warning: Unrecognized parameter %s.\n", param);

        // Check for duplicates
        if (param_index != -1 && params_set[param_index] == 1) {
          fprintf(stderr, "Error: Duplicate parameter %s.\n", param);
          exit(1);
        }
        if (param_index != -1)
          params_set[param_index] = 1;

        // Assign values
        if (param_index == -2)
          exit(1); // impossible.
        else if (param_index == 0)
          read_REAL(value, &commondata->CFL_FACTOR, "CFL_FACTOR");
        else if (param_index == 1)
          read_REAL(value, &commondata->MINIMUM_GLOBAL_WAVESPEED, "MINIMUM_GLOBAL_WAVESPEED");
        else if (param_index == 2)
          read_integer(value, &commondata->NUMGRIDS, "NUMGRIDS");
        else if (param_index == 3)
          read_REAL(value, &commondata->P0_x, "P0_x");
        else if (param_index == 4)
          read_REAL(value, &commondata->P0_y, "P0_y");
        else if (param_index == 5)
          read_REAL(value, &commondata->P0_z, "P0_z");
        else if (param_index == 6)
          read_REAL(value, &commondata->P1_x, "P1_x");
        else if (param_index == 7)
          read_REAL(value, &commondata->P1_y, "P1_y");
        else if (param_index == 8)
          read_REAL(value, &commondata->P1_z, "P1_z");
        else if (param_index == 9)
          read_REAL(value, &commondata->S0_x, "S0_x");
        else if (param_index == 10)
          read_REAL(value, &commondata->S0_y, "S0_y");
        else if (param_index == 11)
          read_REAL(value, &commondata->S0_z, "S0_z");
        else if (param_index == 12)
          read_REAL(value, &commondata->S1_x, "S1_x");
        else if (param_index == 13)
          read_REAL(value, &commondata->S1_y, "S1_y");
        else if (param_index == 14)
          read_REAL(value, &commondata->S1_z, "S1_z");
        else if (param_index == 15)
          read_REAL(value, &commondata->bare_mass_0, "bare_mass_0");
        else if (param_index == 16)
          read_REAL(value, &commondata->bare_mass_1, "bare_mass_1");
        else if (param_index == 17)
          read_REAL(value, &commondata->checkpoint_every, "checkpoint_every");
        else if (param_index == 18)
          read_REAL(value, &commondata->convergence_factor, "convergence_factor");
        else if (param_index == 19)
          read_integer(value, &commondata->diagnostics_output_every, "diagnostics_output_every");
        else if (param_index == 20)
          read_REAL(value, &commondata->eta_damping, "eta_damping");
        else if (param_index == 21)
          read_chararray(value, commondata->gridding_choice, "gridding_choice", 200);
        else if (param_index == 22)
          read_REAL(value, &commondata->log10_current_residual, "log10_current_residual");
        else if (param_index == 23)
          read_REAL(value, &commondata->log10_residual_tolerance, "log10_residual_tolerance");
        else if (param_index == 24)
          read_integer(value, &commondata->nn_max, "nn_max");
        else if (param_index == 25)
          read_chararray(value, commondata->outer_bc_type, "outer_bc_type", 50);
        else if (param_index == 26)
          read_integer(value, &commondata->output_progress_every, "output_progress_every");
        else if (param_index == 27)
          read_boolean(value, &commondata->stop_relaxation, "stop_relaxation");
        else if (param_index == 28)
          read_REAL(value, &commondata->t_final, "t_final");
        else if (param_index == 29)
          read_REAL(value, &commondata->zPunc, "zPunc");
        else {
          fprintf(stderr, "Error: Unrecognized parameter %s.\n", param);
          exit(1); // Exit on unrecognized parameter
        }
      }
    }
  }

  fclose(file);
  // Handling options 3 and 4: Overwriting steerable parameters
  if (option == 3 || option == 4) {
    // For options 3 and 4, we extract the last three arguments as steerable parameters
    read_REAL(argv[argc - number_of_steerable_parameters + 0], &commondata->convergence_factor, "convergence_factor");
  }
}
